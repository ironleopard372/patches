From d10d27c0ffaa6d03bdf270d8a50f98d006c45bf9 Mon Sep 17 00:00:00 2001
From: Nathan Chancellor <nathan@kernel.org>
Date: Fri, 21 May 2021 13:06:12 -0700
Subject: [PATCH 10/10] Revert "btrfs: scrub: per-device bandwidth control"

This reverts commit b4a9f4bee31449bcea678b88146c420130a7a63d.

Link: https://lore.kernel.org/r/alpine.DEB.2.22.394.2105200927570.1771368@ramsan.of.borg/
Signed-off-by: Nathan Chancellor <nathan@kernel.org>
---
 fs/btrfs/scrub.c   | 61 ----------------------------------------------
 fs/btrfs/sysfs.c   | 28 ---------------------
 fs/btrfs/volumes.h |  3 ---
 3 files changed, 92 deletions(-)

diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.c
index bf967e4d8724..6af901539ef2 100644
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@ -165,10 +165,6 @@ struct scrub_ctx {
 	int			readonly;
 	int			pages_per_rd_bio;
 
-	/* State of IO submission throttling affecting the associated device */
-	ktime_t			throttle_deadline;
-	u64			throttle_sent;
-
 	int			is_dev_replace;
 	u64			write_pointer;
 
@@ -609,7 +605,6 @@ static noinline_for_stack struct scrub_ctx *scrub_setup_ctx(
 	spin_lock_init(&sctx->list_lock);
 	spin_lock_init(&sctx->stat_lock);
 	init_waitqueue_head(&sctx->list_wait);
-	sctx->throttle_deadline = 0;
 
 	WARN_ON(sctx->wr_curr_bio != NULL);
 	mutex_init(&sctx->wr_lock);
@@ -1994,60 +1989,6 @@ static void scrub_page_put(struct scrub_page *spage)
 	}
 }
 
-/*
- * Throttling of IO submission, bandwidth-limit based, the timeslice is 1
- * second.  Limit can be set via /sys/fs/UUID/devinfo/devid/scrub_speed_max.
- */
-static void scrub_throttle(struct scrub_ctx *sctx)
-{
-	const int time_slice = 1000;
-	struct scrub_bio *sbio;
-	struct btrfs_device *device;
-	s64 delta;
-	ktime_t now;
-	u32 div;
-	u64 bwlimit;
-
-	sbio = sctx->bios[sctx->curr];
-	device = sbio->dev;
-	bwlimit = READ_ONCE(device->scrub_speed_max);
-	if (bwlimit == 0)
-		return;
-
-	/*
-	 * Slice is divided into intervals when the IO is submitted, adjust by
-	 * bwlimit and maximum of 64 intervals.
-	 */
-	div = max_t(u32, 1, (u32)(bwlimit / (16 * 1024 * 1024)));
-	div = min_t(u32, 64, div);
-
-	/* Start new epoch, set deadline */
-	now = ktime_get();
-	if (sctx->throttle_deadline == 0) {
-		sctx->throttle_deadline = ktime_add_ms(now, time_slice / div);
-		sctx->throttle_sent = 0;
-	}
-
-	/* Still in the time to send? */
-	if (ktime_before(now, sctx->throttle_deadline)) {
-		/* If current bio is within the limit, send it */
-		sctx->throttle_sent += sbio->bio->bi_iter.bi_size;
-		if (sctx->throttle_sent <= bwlimit / div)
-			return;
-
-		/* We're over the limit, sleep until the rest of the slice */
-		delta = ktime_ms_delta(sctx->throttle_deadline, now);
-	} else {
-		/* New request after deadline, start new epoch */
-		delta = 0;
-	}
-
-	if (delta)
-		schedule_timeout_interruptible(delta * HZ / 1000);
-	/* Next call will start the deadline period */
-	sctx->throttle_deadline = 0;
-}
-
 static void scrub_submit(struct scrub_ctx *sctx)
 {
 	struct scrub_bio *sbio;
@@ -2055,8 +1996,6 @@ static void scrub_submit(struct scrub_ctx *sctx)
 	if (sctx->curr == -1)
 		return;
 
-	scrub_throttle(sctx);
-
 	sbio = sctx->bios[sctx->curr];
 	sctx->curr = -1;
 	scrub_pending_bio_inc(sctx);
diff --git a/fs/btrfs/sysfs.c b/fs/btrfs/sysfs.c
index c45d9b6dfdb5..436ac7b4b334 100644
--- a/fs/btrfs/sysfs.c
+++ b/fs/btrfs/sysfs.c
@@ -1455,33 +1455,6 @@ static ssize_t btrfs_devinfo_replace_target_show(struct kobject *kobj,
 }
 BTRFS_ATTR(devid, replace_target, btrfs_devinfo_replace_target_show);
 
-static ssize_t btrfs_devinfo_scrub_speed_max_show(struct kobject *kobj,
-					     struct kobj_attribute *a,
-					     char *buf)
-{
-	struct btrfs_device *device = container_of(kobj, struct btrfs_device,
-						   devid_kobj);
-
-	return scnprintf(buf, PAGE_SIZE, "%llu\n",
-			 READ_ONCE(device->scrub_speed_max));
-}
-
-static ssize_t btrfs_devinfo_scrub_speed_max_store(struct kobject *kobj,
-					      struct kobj_attribute *a,
-					      const char *buf, size_t len)
-{
-	struct btrfs_device *device = container_of(kobj, struct btrfs_device,
-						   devid_kobj);
-	char *endptr;
-	unsigned long long limit;
-
-	limit = memparse(buf, &endptr);
-	WRITE_ONCE(device->scrub_speed_max, limit);
-	return len;
-}
-BTRFS_ATTR_RW(devid, scrub_speed_max, btrfs_devinfo_scrub_speed_max_show,
-	      btrfs_devinfo_scrub_speed_max_store);
-
 static ssize_t btrfs_devinfo_writeable_show(struct kobject *kobj,
 					    struct kobj_attribute *a, char *buf)
 {
@@ -1499,7 +1472,6 @@ static struct attribute *devid_attrs[] = {
 	BTRFS_ATTR_PTR(devid, in_fs_metadata),
 	BTRFS_ATTR_PTR(devid, missing),
 	BTRFS_ATTR_PTR(devid, replace_target),
-	BTRFS_ATTR_PTR(devid, scrub_speed_max),
 	BTRFS_ATTR_PTR(devid, writeable),
 	NULL
 };
diff --git a/fs/btrfs/volumes.h b/fs/btrfs/volumes.h
index c7fc7caf575c..d9aefb04cfaa 100644
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@ -143,9 +143,6 @@ struct btrfs_device {
 	struct completion kobj_unregister;
 	/* For sysfs/FSID/devinfo/devid/ */
 	struct kobject devid_kobj;
-
-	/* Bandwidth limit for scrub, in bytes */
-	u64 scrub_speed_max;
 };
 
 /*
-- 
2.32.0.rc0

