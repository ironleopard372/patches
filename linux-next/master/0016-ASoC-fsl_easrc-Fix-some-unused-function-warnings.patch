From fdf0c73a57d7e545f5c8ea17d970329a95fad3ae Mon Sep 17 00:00:00 2001
From: Nathan Chancellor <natechancellor@gmail.com>
Date: Sun, 26 Apr 2020 05:14:34 -0700
Subject: [PATCH 16/17] ASoC: fsl_easrc: Fix some unused function warnings

Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
---
 sound/soc/fsl/fsl_easrc.c | 250 +++++++++++++++++++-------------------
 1 file changed, 125 insertions(+), 125 deletions(-)

diff --git a/sound/soc/fsl/fsl_easrc.c b/sound/soc/fsl/fsl_easrc.c
index 97658e1f4989..3490e21e96d6 100644
--- a/sound/soc/fsl/fsl_easrc.c
+++ b/sound/soc/fsl/fsl_easrc.c
@@ -300,89 +300,6 @@ static inline uint32_t bits_taps_to_val(unsigned int t)
 	return 0;
 }
 
-static int fsl_easrc_resampler_config(struct fsl_asrc *easrc)
-{
-	struct device *dev = &easrc->pdev->dev;
-	struct fsl_easrc_priv *easrc_priv = easrc->private;
-	struct asrc_firmware_hdr *hdr =  easrc_priv->firmware_hdr;
-	struct interp_params *interp = easrc_priv->interp;
-	struct interp_params *selected_interp = NULL;
-	unsigned int num_coeff;
-	unsigned int i;
-	u64 *coef;
-	u32 *r;
-	int ret;
-
-	if (!hdr) {
-		dev_err(dev, "firmware not loaded!\n");
-		return -ENODEV;
-	}
-
-	for (i = 0; i < hdr->interp_scen; i++) {
-		if ((interp[i].num_taps - 1) !=
-		    bits_taps_to_val(easrc_priv->rs_num_taps))
-			continue;
-
-		coef = interp[i].coeff;
-		selected_interp = &interp[i];
-		dev_dbg(dev, "Selected interp_filter: %u taps - %u phases\n",
-			selected_interp->num_taps,
-			selected_interp->num_phases);
-		break;
-	}
-
-	if (!selected_interp) {
-		dev_err(dev, "failed to get interpreter configuration\n");
-		return -EINVAL;
-	}
-
-	/*
-	 * RS_LOW - first half of center tap of the sinc function
-	 * RS_HIGH - second half of center tap of the sinc function
-	 * This is due to the fact the resampling function must be
-	 * symetrical - i.e. odd number of taps
-	 */
-	r = (uint32_t *)&selected_interp->center_tap;
-	regmap_write(easrc->regmap, REG_EASRC_RCTCL, EASRC_RCTCL_RS_CL(r[0]));
-	regmap_write(easrc->regmap, REG_EASRC_RCTCH, EASRC_RCTCH_RS_CH(r[1]));
-
-	/*
-	 * Write Number of Resampling Coefficient Taps
-	 * 00b - 32-Tap Resampling Filter
-	 * 01b - 64-Tap Resampling Filter
-	 * 10b - 128-Tap Resampling Filter
-	 * 11b - N/A
-	 */
-	regmap_update_bits(easrc->regmap, REG_EASRC_CRCC,
-			   EASRC_CRCC_RS_TAPS_MASK,
-			   EASRC_CRCC_RS_TAPS(easrc_priv->rs_num_taps));
-
-	/* Reset prefilter coefficient pointer back to 0 */
-	ret = fsl_easrc_coeff_mem_ptr_reset(easrc, 0, EASRC_RS_COEFF_MEM);
-	if (ret)
-		return ret;
-
-	/*
-	 * When the filter is programmed to run in:
-	 * 32-tap mode, 16-taps, 128-phases 4-coefficients per phase
-	 * 64-tap mode, 32-taps, 64-phases 4-coefficients per phase
-	 * 128-tap mode, 64-taps, 32-phases 4-coefficients per phase
-	 * This means the number of writes is constant no matter
-	 * the mode we are using
-	 */
-	num_coeff = 16 * 128 * 4;
-
-	for (i = 0; i < num_coeff; i++) {
-		r = (uint32_t *)&coef[i];
-		regmap_write(easrc->regmap, REG_EASRC_CRCM,
-			     EASRC_CRCM_RS_CWD(r[0]));
-		regmap_write(easrc->regmap, REG_EASRC_CRCM,
-			     EASRC_CRCM_RS_CWD(r[1]));
-	}
-
-	return 0;
-}
-
 /**
  *  Scale filter coefficients (64 bits float)
  *  For input float32 normalized range (1.0,-1.0) -> output int[16,24,32]:
@@ -1799,48 +1716,6 @@ static void fsl_easrc_dump_firmware(struct fsl_asrc *easrc)
 }
 #endif
 
-static int fsl_easrc_get_firmware(struct fsl_asrc *easrc)
-{
-	struct fsl_easrc_priv *easrc_priv;
-	const struct firmware **fw_p;
-	u32 pnum, inum, offset;
-	const u8 *data;
-	int ret;
-
-	if (!easrc)
-		return -EINVAL;
-
-	easrc_priv = easrc->private;
-	fw_p = &easrc_priv->fw;
-
-	ret = request_firmware(fw_p, easrc_priv->fw_name, &easrc->pdev->dev);
-	if (ret)
-		return ret;
-
-	data = easrc_priv->fw->data;
-
-	easrc_priv->firmware_hdr = (struct asrc_firmware_hdr *)data;
-	pnum = easrc_priv->firmware_hdr->prefil_scen;
-	inum = easrc_priv->firmware_hdr->interp_scen;
-
-	if (inum) {
-		offset = sizeof(struct asrc_firmware_hdr);
-		easrc_priv->interp = (struct interp_params *)(data + offset);
-	}
-
-	if (pnum) {
-		offset = sizeof(struct asrc_firmware_hdr) +
-				inum * sizeof(struct interp_params);
-		easrc_priv->prefil = (struct prefil_params *)(data + offset);
-	}
-
-#ifdef DEBUG
-	fsl_easrc_dump_firmware(easrc);
-#endif
-
-	return 0;
-}
-
 static irqreturn_t fsl_easrc_isr(int irq, void *dev_id)
 {
 	struct fsl_asrc *easrc = (struct fsl_asrc *)dev_id;
@@ -1993,6 +1868,131 @@ static int fsl_easrc_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
+static int fsl_easrc_resampler_config(struct fsl_asrc *easrc)
+{
+	struct device *dev = &easrc->pdev->dev;
+	struct fsl_easrc_priv *easrc_priv = easrc->private;
+	struct asrc_firmware_hdr *hdr =  easrc_priv->firmware_hdr;
+	struct interp_params *interp = easrc_priv->interp;
+	struct interp_params *selected_interp = NULL;
+	unsigned int num_coeff;
+	unsigned int i;
+	u64 *coef;
+	u32 *r;
+	int ret;
+
+	if (!hdr) {
+		dev_err(dev, "firmware not loaded!\n");
+		return -ENODEV;
+	}
+
+	for (i = 0; i < hdr->interp_scen; i++) {
+		if ((interp[i].num_taps - 1) !=
+		    bits_taps_to_val(easrc_priv->rs_num_taps))
+			continue;
+
+		coef = interp[i].coeff;
+		selected_interp = &interp[i];
+		dev_dbg(dev, "Selected interp_filter: %u taps - %u phases\n",
+			selected_interp->num_taps,
+			selected_interp->num_phases);
+		break;
+	}
+
+	if (!selected_interp) {
+		dev_err(dev, "failed to get interpreter configuration\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * RS_LOW - first half of center tap of the sinc function
+	 * RS_HIGH - second half of center tap of the sinc function
+	 * This is due to the fact the resampling function must be
+	 * symetrical - i.e. odd number of taps
+	 */
+	r = (uint32_t *)&selected_interp->center_tap;
+	regmap_write(easrc->regmap, REG_EASRC_RCTCL, EASRC_RCTCL_RS_CL(r[0]));
+	regmap_write(easrc->regmap, REG_EASRC_RCTCH, EASRC_RCTCH_RS_CH(r[1]));
+
+	/*
+	 * Write Number of Resampling Coefficient Taps
+	 * 00b - 32-Tap Resampling Filter
+	 * 01b - 64-Tap Resampling Filter
+	 * 10b - 128-Tap Resampling Filter
+	 * 11b - N/A
+	 */
+	regmap_update_bits(easrc->regmap, REG_EASRC_CRCC,
+			   EASRC_CRCC_RS_TAPS_MASK,
+			   EASRC_CRCC_RS_TAPS(easrc_priv->rs_num_taps));
+
+	/* Reset prefilter coefficient pointer back to 0 */
+	ret = fsl_easrc_coeff_mem_ptr_reset(easrc, 0, EASRC_RS_COEFF_MEM);
+	if (ret)
+		return ret;
+
+	/*
+	 * When the filter is programmed to run in:
+	 * 32-tap mode, 16-taps, 128-phases 4-coefficients per phase
+	 * 64-tap mode, 32-taps, 64-phases 4-coefficients per phase
+	 * 128-tap mode, 64-taps, 32-phases 4-coefficients per phase
+	 * This means the number of writes is constant no matter
+	 * the mode we are using
+	 */
+	num_coeff = 16 * 128 * 4;
+
+	for (i = 0; i < num_coeff; i++) {
+		r = (uint32_t *)&coef[i];
+		regmap_write(easrc->regmap, REG_EASRC_CRCM,
+			     EASRC_CRCM_RS_CWD(r[0]));
+		regmap_write(easrc->regmap, REG_EASRC_CRCM,
+			     EASRC_CRCM_RS_CWD(r[1]));
+	}
+
+	return 0;
+}
+
+static int fsl_easrc_get_firmware(struct fsl_asrc *easrc)
+{
+	struct fsl_easrc_priv *easrc_priv;
+	const struct firmware **fw_p;
+	u32 pnum, inum, offset;
+	const u8 *data;
+	int ret;
+
+	if (!easrc)
+		return -EINVAL;
+
+	easrc_priv = easrc->private;
+	fw_p = &easrc_priv->fw;
+
+	ret = request_firmware(fw_p, easrc_priv->fw_name, &easrc->pdev->dev);
+	if (ret)
+		return ret;
+
+	data = easrc_priv->fw->data;
+
+	easrc_priv->firmware_hdr = (struct asrc_firmware_hdr *)data;
+	pnum = easrc_priv->firmware_hdr->prefil_scen;
+	inum = easrc_priv->firmware_hdr->interp_scen;
+
+	if (inum) {
+		offset = sizeof(struct asrc_firmware_hdr);
+		easrc_priv->interp = (struct interp_params *)(data + offset);
+	}
+
+	if (pnum) {
+		offset = sizeof(struct asrc_firmware_hdr) +
+				inum * sizeof(struct interp_params);
+		easrc_priv->prefil = (struct prefil_params *)(data + offset);
+	}
+
+#ifdef DEBUG
+	fsl_easrc_dump_firmware(easrc);
+#endif
+
+	return 0;
+}
+
 static int fsl_easrc_runtime_suspend(struct device *dev)
 {
 	struct fsl_asrc *easrc = dev_get_drvdata(dev);
-- 
2.26.2

