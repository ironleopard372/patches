From 9d1d531535b3fc6d5e30d9602602f1b6d860f70f Mon Sep 17 00:00:00 2001
From: Nathan Chancellor <natechancellor@gmail.com>
Date: Thu, 29 Oct 2020 18:13:33 -0700
Subject: [PATCH 14/15] clk: imx: scu: Revert all patches on clk/imx branch

This reverts the following commits:

ea0c5cbaf8b7 ("clk: imx: lpcg: add suspend/resume support")
18cdbad40c6c ("clk: imx: clk-imx8qxp-lpcg: add runtime pm support")
a4bfc85ccf37 ("clk: imx: lpcg: allow lpcg clk to take device pointer")
d5f1e6a2bb61 ("clk: imx: imx8qxp-lpcg: add parsing clocks from device tree")
d0409631f466 ("clk: imx: scu: add suspend/resume support")
78edeb080330 ("clk: imx: scu: add runtime pm support")
2f1a2c1d00bc ("clk: imx: scu: allow scu clk to take device pointer")
0d5f1f4731b5 ("clk: imx: scu: bypass cpu power domains")
77d8f3068c63 ("clk: imx: scu: add two cells binding support")

Link: https://lore.kernel.org/r/20201030010600.GA2760@Ryzen-9-3900X.localdomain/
Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
---
 drivers/clk/imx/clk-imx8qxp-lpcg.c | 139 -----------------
 drivers/clk/imx/clk-imx8qxp.c      | 136 ++++++++---------
 drivers/clk/imx/clk-lpcg-scu.c     |  53 +------
 drivers/clk/imx/clk-scu.c          | 234 +----------------------------
 drivers/clk/imx/clk-scu.h          |  56 ++-----
 5 files changed, 79 insertions(+), 539 deletions(-)

diff --git a/drivers/clk/imx/clk-imx8qxp-lpcg.c b/drivers/clk/imx/clk-imx8qxp-lpcg.c
index d3e905cf867d..e947a70054ac 100644
--- a/drivers/clk/imx/clk-imx8qxp-lpcg.c
+++ b/drivers/clk/imx/clk-imx8qxp-lpcg.c
@@ -9,10 +9,8 @@
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/of.h>
-#include <linux/of_address.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
 #include <linux/slab.h>
 
 #include "clk-scu.h"
@@ -159,135 +157,6 @@ static const struct imx8qxp_ss_lpcg imx8qxp_ss_lsio = {
 	.num_max = IMX_LSIO_LPCG_CLK_END,
 };
 
-#define IMX_LPCG_MAX_CLKS	8
-
-static struct clk_hw *imx_lpcg_of_clk_src_get(struct of_phandle_args *clkspec,
-					      void *data)
-{
-	struct clk_hw_onecell_data *hw_data = data;
-	unsigned int idx = clkspec->args[0] / 4;
-
-	if (idx >= hw_data->num) {
-		pr_err("%s: invalid index %u\n", __func__, idx);
-		return ERR_PTR(-EINVAL);
-	}
-
-	return hw_data->hws[idx];
-}
-
-static int imx_lpcg_parse_clks_from_dt(struct platform_device *pdev,
-				       struct device_node *np)
-{
-	const char *output_names[IMX_LPCG_MAX_CLKS];
-	const char *parent_names[IMX_LPCG_MAX_CLKS];
-	unsigned int bit_offset[IMX_LPCG_MAX_CLKS];
-	struct clk_hw_onecell_data *clk_data;
-	struct clk_hw **clk_hws;
-	struct resource *res;
-	void __iomem *base;
-	int count;
-	int idx;
-	int ret;
-	int i;
-
-	if (!of_device_is_compatible(np, "fsl,imx8qxp-lpcg"))
-		return -EINVAL;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(base))
-		return PTR_ERR(base);
-
-	count = of_property_count_u32_elems(np, "clock-indices");
-	if (count < 0) {
-		dev_err(&pdev->dev, "failed to count clocks\n");
-		return -EINVAL;
-	}
-
-	/*
-	 * A trick here is that we set the num of clks to the MAX instead
-	 * of the count from clock-indices because one LPCG supports up to
-	 * 8 clock outputs which each of them is fixed to 4 bits. Then we can
-	 * easily get the clock by clk-indices (bit-offset) / 4.
-	 * And the cost is very limited few pointers.
-	 */
-
-	clk_data = devm_kzalloc(&pdev->dev, struct_size(clk_data, hws,
-				IMX_LPCG_MAX_CLKS), GFP_KERNEL);
-	if (!clk_data)
-		return -ENOMEM;
-
-	clk_data->num = IMX_LPCG_MAX_CLKS;
-	clk_hws = clk_data->hws;
-
-	ret = of_property_read_u32_array(np, "clock-indices", bit_offset,
-					 count);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "failed to read clock-indices\n");
-		return -EINVAL;
-	}
-
-	ret = of_clk_parent_fill(np, parent_names, count);
-	if (ret != count) {
-		dev_err(&pdev->dev, "failed to get clock parent names\n");
-		return count;
-	}
-
-	ret = of_property_read_string_array(np, "clock-output-names",
-					    output_names, count);
-	if (ret != count) {
-		dev_err(&pdev->dev, "failed to read clock-output-names\n");
-		return -EINVAL;
-	}
-
-	pm_runtime_get_noresume(&pdev->dev);
-	pm_runtime_set_active(&pdev->dev);
-	pm_runtime_set_autosuspend_delay(&pdev->dev, 500);
-	pm_runtime_use_autosuspend(&pdev->dev);
-	pm_runtime_enable(&pdev->dev);
-
-	for (i = 0; i < count; i++) {
-		idx = bit_offset[i] / 4;
-		if (idx > IMX_LPCG_MAX_CLKS) {
-			dev_warn(&pdev->dev, "invalid bit offset of clock %d\n",
-				 i);
-			ret = -EINVAL;
-			goto unreg;
-		}
-
-		clk_hws[idx] = imx_clk_lpcg_scu_dev(&pdev->dev, output_names[i],
-						    parent_names[i], 0, base,
-						    bit_offset[i], false);
-		if (IS_ERR(clk_hws[idx])) {
-			dev_warn(&pdev->dev, "failed to register clock %d\n",
-				 idx);
-			ret = PTR_ERR(clk_hws[idx]);
-			goto unreg;
-		}
-	}
-
-	ret = devm_of_clk_add_hw_provider(&pdev->dev, imx_lpcg_of_clk_src_get,
-					  clk_data);
-	if (ret)
-		goto unreg;
-
-	pm_runtime_mark_last_busy(&pdev->dev);
-	pm_runtime_put_autosuspend(&pdev->dev);
-
-	return 0;
-
-unreg:
-	while (--i >= 0) {
-		idx = bit_offset[i] / 4;
-		if (clk_hws[idx])
-			imx_clk_lpcg_scu_unregister(clk_hws[idx]);
-	}
-
-	pm_runtime_disable(&pdev->dev);
-
-	return ret;
-}
-
 static int imx8qxp_lpcg_clk_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -298,14 +167,8 @@ static int imx8qxp_lpcg_clk_probe(struct platform_device *pdev)
 	struct resource *res;
 	struct clk_hw **clks;
 	void __iomem *base;
-	int ret;
 	int i;
 
-	/* try new binding to parse clocks from device tree first */
-	ret = imx_lpcg_parse_clks_from_dt(pdev, np);
-	if (!ret)
-		return 0;
-
 	ss_lpcg = of_device_get_match_data(dev);
 	if (!ss_lpcg)
 		return -ENODEV;
@@ -356,7 +219,6 @@ static const struct of_device_id imx8qxp_lpcg_match[] = {
 	{ .compatible = "fsl,imx8qxp-lpcg-adma", &imx8qxp_ss_adma, },
 	{ .compatible = "fsl,imx8qxp-lpcg-conn", &imx8qxp_ss_conn, },
 	{ .compatible = "fsl,imx8qxp-lpcg-lsio", &imx8qxp_ss_lsio, },
-	{ .compatible = "fsl,imx8qxp-lpcg", NULL },
 	{ /* sentinel */ }
 };
 
@@ -364,7 +226,6 @@ static struct platform_driver imx8qxp_lpcg_clk_driver = {
 	.driver = {
 		.name = "imx8qxp-lpcg-clk",
 		.of_match_table = imx8qxp_lpcg_match,
-		.pm = &imx_clk_lpcg_scu_pm_ops,
 		.suppress_bind_attrs = true,
 	},
 	.probe = imx8qxp_lpcg_clk_probe,
diff --git a/drivers/clk/imx/clk-imx8qxp.c b/drivers/clk/imx/clk-imx8qxp.c
index 5b3d4ede7c7c..d650ca33cdc8 100644
--- a/drivers/clk/imx/clk-imx8qxp.c
+++ b/drivers/clk/imx/clk-imx8qxp.c
@@ -22,10 +22,9 @@ static int imx8qxp_clk_probe(struct platform_device *pdev)
 	struct device_node *ccm_node = pdev->dev.of_node;
 	struct clk_hw_onecell_data *clk_data;
 	struct clk_hw **clks;
-	u32 clk_cells;
 	int ret, i;
 
-	ret = imx_clk_scu_init(ccm_node);
+	ret = imx_clk_scu_init();
 	if (ret)
 		return ret;
 
@@ -34,9 +33,6 @@ static int imx8qxp_clk_probe(struct platform_device *pdev)
 	if (!clk_data)
 		return -ENOMEM;
 
-	if (of_property_read_u32(ccm_node, "#clock-cells", &clk_cells))
-		return -EINVAL;
-
 	clk_data->num = IMX_SCU_CLK_END;
 	clks = clk_data->hws;
 
@@ -59,78 +55,78 @@ static int imx8qxp_clk_probe(struct platform_device *pdev)
 	clks[IMX_LSIO_BUS_CLK]		= clk_hw_register_fixed_rate(NULL, "lsio_bus_clk_root", NULL, 0, 100000000);
 
 	/* ARM core */
-	clks[IMX_A35_CLK]		= imx_clk_scu("a35_clk", IMX_SC_R_A35, IMX_SC_PM_CLK_CPU, clk_cells);
+	clks[IMX_A35_CLK]		= imx_clk_scu("a35_clk", IMX_SC_R_A35, IMX_SC_PM_CLK_CPU);
 
 	/* LSIO SS */
-	clks[IMX_LSIO_PWM0_CLK]		= imx_clk_scu("pwm0_clk", IMX_SC_R_PWM_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_PWM1_CLK]		= imx_clk_scu("pwm1_clk", IMX_SC_R_PWM_1, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_PWM2_CLK]		= imx_clk_scu("pwm2_clk", IMX_SC_R_PWM_2, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_PWM3_CLK]		= imx_clk_scu("pwm3_clk", IMX_SC_R_PWM_3, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_PWM4_CLK]		= imx_clk_scu("pwm4_clk", IMX_SC_R_PWM_4, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_PWM5_CLK]		= imx_clk_scu("pwm5_clk", IMX_SC_R_PWM_5, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_PWM6_CLK]		= imx_clk_scu("pwm6_clk", IMX_SC_R_PWM_6, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_PWM7_CLK]		= imx_clk_scu("pwm7_clk", IMX_SC_R_PWM_7, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_GPT0_CLK]		= imx_clk_scu("gpt0_clk", IMX_SC_R_GPT_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_GPT1_CLK]		= imx_clk_scu("gpt1_clk", IMX_SC_R_GPT_1, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_GPT2_CLK]		= imx_clk_scu("gpt2_clk", IMX_SC_R_GPT_2, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_GPT3_CLK]		= imx_clk_scu("gpt3_clk", IMX_SC_R_GPT_3, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_GPT4_CLK]		= imx_clk_scu("gpt4_clk", IMX_SC_R_GPT_4, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_FSPI0_CLK]	= imx_clk_scu("fspi0_clk", IMX_SC_R_FSPI_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_LSIO_FSPI1_CLK]	= imx_clk_scu("fspi1_clk", IMX_SC_R_FSPI_1, IMX_SC_PM_CLK_PER, clk_cells);
+	clks[IMX_LSIO_PWM0_CLK]		= imx_clk_scu("pwm0_clk", IMX_SC_R_PWM_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_PWM1_CLK]		= imx_clk_scu("pwm1_clk", IMX_SC_R_PWM_1, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_PWM2_CLK]		= imx_clk_scu("pwm2_clk", IMX_SC_R_PWM_2, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_PWM3_CLK]		= imx_clk_scu("pwm3_clk", IMX_SC_R_PWM_3, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_PWM4_CLK]		= imx_clk_scu("pwm4_clk", IMX_SC_R_PWM_4, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_PWM5_CLK]		= imx_clk_scu("pwm5_clk", IMX_SC_R_PWM_5, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_PWM6_CLK]		= imx_clk_scu("pwm6_clk", IMX_SC_R_PWM_6, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_PWM7_CLK]		= imx_clk_scu("pwm7_clk", IMX_SC_R_PWM_7, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_GPT0_CLK]		= imx_clk_scu("gpt0_clk", IMX_SC_R_GPT_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_GPT1_CLK]		= imx_clk_scu("gpt1_clk", IMX_SC_R_GPT_1, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_GPT2_CLK]		= imx_clk_scu("gpt2_clk", IMX_SC_R_GPT_2, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_GPT3_CLK]		= imx_clk_scu("gpt3_clk", IMX_SC_R_GPT_3, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_GPT4_CLK]		= imx_clk_scu("gpt4_clk", IMX_SC_R_GPT_4, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_FSPI0_CLK]	= imx_clk_scu("fspi0_clk", IMX_SC_R_FSPI_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_LSIO_FSPI1_CLK]	= imx_clk_scu("fspi1_clk", IMX_SC_R_FSPI_1, IMX_SC_PM_CLK_PER);
 
 	/* ADMA SS */
-	clks[IMX_ADMA_UART0_CLK]	= imx_clk_scu("uart0_clk", IMX_SC_R_UART_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_UART1_CLK]	= imx_clk_scu("uart1_clk", IMX_SC_R_UART_1, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_UART2_CLK]	= imx_clk_scu("uart2_clk", IMX_SC_R_UART_2, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_UART3_CLK]	= imx_clk_scu("uart3_clk", IMX_SC_R_UART_3, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_SPI0_CLK]		= imx_clk_scu("spi0_clk",  IMX_SC_R_SPI_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_SPI1_CLK]		= imx_clk_scu("spi1_clk",  IMX_SC_R_SPI_1, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_SPI2_CLK]		= imx_clk_scu("spi2_clk",  IMX_SC_R_SPI_2, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_SPI3_CLK]		= imx_clk_scu("spi3_clk",  IMX_SC_R_SPI_3, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_CAN0_CLK]		= imx_clk_scu("can0_clk",  IMX_SC_R_CAN_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_I2C0_CLK]		= imx_clk_scu("i2c0_clk",  IMX_SC_R_I2C_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_I2C1_CLK]		= imx_clk_scu("i2c1_clk",  IMX_SC_R_I2C_1, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_I2C2_CLK]		= imx_clk_scu("i2c2_clk",  IMX_SC_R_I2C_2, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_I2C3_CLK]		= imx_clk_scu("i2c3_clk",  IMX_SC_R_I2C_3, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_FTM0_CLK]		= imx_clk_scu("ftm0_clk",  IMX_SC_R_FTM_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_FTM1_CLK]		= imx_clk_scu("ftm1_clk",  IMX_SC_R_FTM_1, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_ADC0_CLK]		= imx_clk_scu("adc0_clk",  IMX_SC_R_ADC_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_PWM_CLK]		= imx_clk_scu("pwm_clk",   IMX_SC_R_LCD_0_PWM_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_ADMA_LCD_CLK]		= imx_clk_scu("lcd_clk",   IMX_SC_R_LCD_0, IMX_SC_PM_CLK_PER, clk_cells);
+	clks[IMX_ADMA_UART0_CLK]	= imx_clk_scu("uart0_clk", IMX_SC_R_UART_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_UART1_CLK]	= imx_clk_scu("uart1_clk", IMX_SC_R_UART_1, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_UART2_CLK]	= imx_clk_scu("uart2_clk", IMX_SC_R_UART_2, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_UART3_CLK]	= imx_clk_scu("uart3_clk", IMX_SC_R_UART_3, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_SPI0_CLK]		= imx_clk_scu("spi0_clk",  IMX_SC_R_SPI_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_SPI1_CLK]		= imx_clk_scu("spi1_clk",  IMX_SC_R_SPI_1, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_SPI2_CLK]		= imx_clk_scu("spi2_clk",  IMX_SC_R_SPI_2, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_SPI3_CLK]		= imx_clk_scu("spi3_clk",  IMX_SC_R_SPI_3, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_CAN0_CLK]		= imx_clk_scu("can0_clk",  IMX_SC_R_CAN_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_I2C0_CLK]		= imx_clk_scu("i2c0_clk",  IMX_SC_R_I2C_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_I2C1_CLK]		= imx_clk_scu("i2c1_clk",  IMX_SC_R_I2C_1, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_I2C2_CLK]		= imx_clk_scu("i2c2_clk",  IMX_SC_R_I2C_2, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_I2C3_CLK]		= imx_clk_scu("i2c3_clk",  IMX_SC_R_I2C_3, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_FTM0_CLK]		= imx_clk_scu("ftm0_clk",  IMX_SC_R_FTM_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_FTM1_CLK]		= imx_clk_scu("ftm1_clk",  IMX_SC_R_FTM_1, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_ADC0_CLK]		= imx_clk_scu("adc0_clk",  IMX_SC_R_ADC_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_PWM_CLK]		= imx_clk_scu("pwm_clk",   IMX_SC_R_LCD_0_PWM_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_ADMA_LCD_CLK]		= imx_clk_scu("lcd_clk",   IMX_SC_R_LCD_0, IMX_SC_PM_CLK_PER);
 
 	/* Connectivity */
-	clks[IMX_CONN_SDHC0_CLK]	= imx_clk_scu("sdhc0_clk", IMX_SC_R_SDHC_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_CONN_SDHC1_CLK]	= imx_clk_scu("sdhc1_clk", IMX_SC_R_SDHC_1, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_CONN_SDHC2_CLK]	= imx_clk_scu("sdhc2_clk", IMX_SC_R_SDHC_2, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_CONN_ENET0_ROOT_CLK]	= imx_clk_scu("enet0_clk", IMX_SC_R_ENET_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_CONN_ENET0_BYPASS_CLK]	= imx_clk_scu("enet0_bypass_clk", IMX_SC_R_ENET_0, IMX_SC_PM_CLK_BYPASS, clk_cells);
-	clks[IMX_CONN_ENET0_RGMII_CLK]	= imx_clk_scu("enet0_rgmii_clk", IMX_SC_R_ENET_0, IMX_SC_PM_CLK_MISC0, clk_cells);
-	clks[IMX_CONN_ENET1_ROOT_CLK]	= imx_clk_scu("enet1_clk", IMX_SC_R_ENET_1, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_CONN_ENET1_BYPASS_CLK]	= imx_clk_scu("enet1_bypass_clk", IMX_SC_R_ENET_1, IMX_SC_PM_CLK_BYPASS, clk_cells);
-	clks[IMX_CONN_ENET1_RGMII_CLK]	= imx_clk_scu("enet1_rgmii_clk", IMX_SC_R_ENET_1, IMX_SC_PM_CLK_MISC0, clk_cells);
-	clks[IMX_CONN_GPMI_BCH_IO_CLK]	= imx_clk_scu("gpmi_io_clk", IMX_SC_R_NAND, IMX_SC_PM_CLK_MST_BUS, clk_cells);
-	clks[IMX_CONN_GPMI_BCH_CLK]	= imx_clk_scu("gpmi_bch_clk", IMX_SC_R_NAND, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_CONN_USB2_ACLK]	= imx_clk_scu("usb3_aclk_div", IMX_SC_R_USB_2, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_CONN_USB2_BUS_CLK]	= imx_clk_scu("usb3_bus_div", IMX_SC_R_USB_2, IMX_SC_PM_CLK_MST_BUS, clk_cells);
-	clks[IMX_CONN_USB2_LPM_CLK]	= imx_clk_scu("usb3_lpm_div", IMX_SC_R_USB_2, IMX_SC_PM_CLK_MISC, clk_cells);
+	clks[IMX_CONN_SDHC0_CLK]	= imx_clk_scu("sdhc0_clk", IMX_SC_R_SDHC_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_CONN_SDHC1_CLK]	= imx_clk_scu("sdhc1_clk", IMX_SC_R_SDHC_1, IMX_SC_PM_CLK_PER);
+	clks[IMX_CONN_SDHC2_CLK]	= imx_clk_scu("sdhc2_clk", IMX_SC_R_SDHC_2, IMX_SC_PM_CLK_PER);
+	clks[IMX_CONN_ENET0_ROOT_CLK]	= imx_clk_scu("enet0_clk", IMX_SC_R_ENET_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_CONN_ENET0_BYPASS_CLK]	= imx_clk_scu("enet0_bypass_clk", IMX_SC_R_ENET_0, IMX_SC_PM_CLK_BYPASS);
+	clks[IMX_CONN_ENET0_RGMII_CLK]	= imx_clk_scu("enet0_rgmii_clk", IMX_SC_R_ENET_0, IMX_SC_PM_CLK_MISC0);
+	clks[IMX_CONN_ENET1_ROOT_CLK]	= imx_clk_scu("enet1_clk", IMX_SC_R_ENET_1, IMX_SC_PM_CLK_PER);
+	clks[IMX_CONN_ENET1_BYPASS_CLK]	= imx_clk_scu("enet1_bypass_clk", IMX_SC_R_ENET_1, IMX_SC_PM_CLK_BYPASS);
+	clks[IMX_CONN_ENET1_RGMII_CLK]	= imx_clk_scu("enet1_rgmii_clk", IMX_SC_R_ENET_1, IMX_SC_PM_CLK_MISC0);
+	clks[IMX_CONN_GPMI_BCH_IO_CLK]	= imx_clk_scu("gpmi_io_clk", IMX_SC_R_NAND, IMX_SC_PM_CLK_MST_BUS);
+	clks[IMX_CONN_GPMI_BCH_CLK]	= imx_clk_scu("gpmi_bch_clk", IMX_SC_R_NAND, IMX_SC_PM_CLK_PER);
+	clks[IMX_CONN_USB2_ACLK]	= imx_clk_scu("usb3_aclk_div", IMX_SC_R_USB_2, IMX_SC_PM_CLK_PER);
+	clks[IMX_CONN_USB2_BUS_CLK]	= imx_clk_scu("usb3_bus_div", IMX_SC_R_USB_2, IMX_SC_PM_CLK_MST_BUS);
+	clks[IMX_CONN_USB2_LPM_CLK]	= imx_clk_scu("usb3_lpm_div", IMX_SC_R_USB_2, IMX_SC_PM_CLK_MISC);
 
 	/* Display controller SS */
-	clks[IMX_DC0_DISP0_CLK]		= imx_clk_scu("dc0_disp0_clk", IMX_SC_R_DC_0, IMX_SC_PM_CLK_MISC0, clk_cells);
-	clks[IMX_DC0_DISP1_CLK]		= imx_clk_scu("dc0_disp1_clk", IMX_SC_R_DC_0, IMX_SC_PM_CLK_MISC1, clk_cells);
+	clks[IMX_DC0_DISP0_CLK]		= imx_clk_scu("dc0_disp0_clk", IMX_SC_R_DC_0, IMX_SC_PM_CLK_MISC0);
+	clks[IMX_DC0_DISP1_CLK]		= imx_clk_scu("dc0_disp1_clk", IMX_SC_R_DC_0, IMX_SC_PM_CLK_MISC1);
 
 	/* MIPI-LVDS SS */
-	clks[IMX_MIPI0_I2C0_CLK]	= imx_clk_scu("mipi0_i2c0_clk", IMX_SC_R_MIPI_0_I2C_0, IMX_SC_PM_CLK_MISC2, clk_cells);
-	clks[IMX_MIPI0_I2C1_CLK]	= imx_clk_scu("mipi0_i2c1_clk", IMX_SC_R_MIPI_0_I2C_1, IMX_SC_PM_CLK_MISC2, clk_cells);
+	clks[IMX_MIPI0_I2C0_CLK]	= imx_clk_scu("mipi0_i2c0_clk", IMX_SC_R_MIPI_0_I2C_0, IMX_SC_PM_CLK_MISC2);
+	clks[IMX_MIPI0_I2C1_CLK]	= imx_clk_scu("mipi0_i2c1_clk", IMX_SC_R_MIPI_0_I2C_1, IMX_SC_PM_CLK_MISC2);
 
 	/* MIPI CSI SS */
-	clks[IMX_CSI0_CORE_CLK]		= imx_clk_scu("mipi_csi0_core_clk", IMX_SC_R_CSI_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_CSI0_ESC_CLK]		= imx_clk_scu("mipi_csi0_esc_clk",  IMX_SC_R_CSI_0, IMX_SC_PM_CLK_MISC, clk_cells);
-	clks[IMX_CSI0_I2C0_CLK]		= imx_clk_scu("mipi_csi0_i2c0_clk", IMX_SC_R_CSI_0_I2C_0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_CSI0_PWM0_CLK]		= imx_clk_scu("mipi_csi0_pwm0_clk", IMX_SC_R_CSI_0_PWM_0, IMX_SC_PM_CLK_PER, clk_cells);
+	clks[IMX_CSI0_CORE_CLK]		= imx_clk_scu("mipi_csi0_core_clk", IMX_SC_R_CSI_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_CSI0_ESC_CLK]		= imx_clk_scu("mipi_csi0_esc_clk",  IMX_SC_R_CSI_0, IMX_SC_PM_CLK_MISC);
+	clks[IMX_CSI0_I2C0_CLK]		= imx_clk_scu("mipi_csi0_i2c0_clk", IMX_SC_R_CSI_0_I2C_0, IMX_SC_PM_CLK_PER);
+	clks[IMX_CSI0_PWM0_CLK]		= imx_clk_scu("mipi_csi0_pwm0_clk", IMX_SC_R_CSI_0_PWM_0, IMX_SC_PM_CLK_PER);
 
 	/* GPU SS */
-	clks[IMX_GPU0_CORE_CLK]		= imx_clk_scu("gpu_core0_clk",	 IMX_SC_R_GPU_0_PID0, IMX_SC_PM_CLK_PER, clk_cells);
-	clks[IMX_GPU0_SHADER_CLK]	= imx_clk_scu("gpu_shader0_clk", IMX_SC_R_GPU_0_PID0, IMX_SC_PM_CLK_MISC, clk_cells);
+	clks[IMX_GPU0_CORE_CLK]		= imx_clk_scu("gpu_core0_clk",	 IMX_SC_R_GPU_0_PID0, IMX_SC_PM_CLK_PER);
+	clks[IMX_GPU0_SHADER_CLK]	= imx_clk_scu("gpu_shader0_clk", IMX_SC_R_GPU_0_PID0, IMX_SC_PM_CLK_MISC);
 
 	for (i = 0; i < clk_data->num; i++) {
 		if (IS_ERR(clks[i]))
@@ -138,19 +134,7 @@ static int imx8qxp_clk_probe(struct platform_device *pdev)
 				i, PTR_ERR(clks[i]));
 	}
 
-	if (clk_cells == 2) {
-		ret = of_clk_add_hw_provider(ccm_node, imx_scu_of_clk_src_get, imx_scu_clks);
-		if (ret)
-			imx_clk_scu_unregister();
-	} else {
-		/*
-		 * legacy binding code path doesn't unregister here because
-		 * it will be removed later.
-		 */
-		ret = of_clk_add_hw_provider(ccm_node, of_clk_hw_onecell_get, clk_data);
-	}
-
-	return ret;
+	return of_clk_add_hw_provider(ccm_node, of_clk_hw_onecell_get, clk_data);
 }
 
 static const struct of_device_id imx8qxp_match[] = {
diff --git a/drivers/clk/imx/clk-lpcg-scu.c b/drivers/clk/imx/clk-lpcg-scu.c
index 77be7632866d..1f0e44f921ae 100644
--- a/drivers/clk/imx/clk-lpcg-scu.c
+++ b/drivers/clk/imx/clk-lpcg-scu.c
@@ -34,9 +34,6 @@ struct clk_lpcg_scu {
 	void __iomem *reg;
 	u8 bit_idx;
 	bool hw_gate;
-
-	/* for state save&restore */
-	u32 state;
 };
 
 #define to_clk_lpcg_scu(_hw) container_of(_hw, struct clk_lpcg_scu, hw)
@@ -84,9 +81,9 @@ static const struct clk_ops clk_lpcg_scu_ops = {
 	.disable = clk_lpcg_scu_disable,
 };
 
-struct clk_hw *__imx_clk_lpcg_scu(struct device *dev, const char *name,
-				  const char *parent_name, unsigned long flags,
-				  void __iomem *reg, u8 bit_idx, bool hw_gate)
+struct clk_hw *imx_clk_lpcg_scu(const char *name, const char *parent_name,
+				unsigned long flags, void __iomem *reg,
+				u8 bit_idx, bool hw_gate)
 {
 	struct clk_lpcg_scu *clk;
 	struct clk_init_data init;
@@ -110,53 +107,11 @@ struct clk_hw *__imx_clk_lpcg_scu(struct device *dev, const char *name,
 	clk->hw.init = &init;
 
 	hw = &clk->hw;
-	ret = clk_hw_register(dev, hw);
+	ret = clk_hw_register(NULL, hw);
 	if (ret) {
 		kfree(clk);
 		hw = ERR_PTR(ret);
 	}
 
-	if (dev)
-		dev_set_drvdata(dev, clk);
-
 	return hw;
 }
-
-void imx_clk_lpcg_scu_unregister(struct clk_hw *hw)
-{
-	struct clk_lpcg_scu *clk = to_clk_lpcg_scu(hw);
-
-	clk_hw_unregister(&clk->hw);
-	kfree(clk);
-}
-
-static int __maybe_unused imx_clk_lpcg_scu_suspend(struct device *dev)
-{
-	struct clk_lpcg_scu *clk = dev_get_drvdata(dev);
-
-	clk->state = readl_relaxed(clk->reg);
-	dev_dbg(dev, "save lpcg state 0x%x\n", clk->state);
-
-	return 0;
-}
-
-static int __maybe_unused imx_clk_lpcg_scu_resume(struct device *dev)
-{
-	struct clk_lpcg_scu *clk = dev_get_drvdata(dev);
-
-	/*
-	 * FIXME: Sometimes writes don't work unless the CPU issues
-	 * them twice
-	 */
-
-	writel(clk->state, clk->reg);
-	writel(clk->state, clk->reg);
-	dev_dbg(dev, "restore lpcg state 0x%x\n", clk->state);
-
-	return 0;
-}
-
-const struct dev_pm_ops imx_clk_lpcg_scu_pm_ops = {
-	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(imx_clk_lpcg_scu_suspend,
-				      imx_clk_lpcg_scu_resume)
-};
diff --git a/drivers/clk/imx/clk-scu.c b/drivers/clk/imx/clk-scu.c
index 229a290ca5b6..b8b2072742a5 100644
--- a/drivers/clk/imx/clk-scu.c
+++ b/drivers/clk/imx/clk-scu.c
@@ -8,10 +8,6 @@
 #include <linux/arm-smccc.h>
 #include <linux/clk-provider.h>
 #include <linux/err.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-#include <linux/pm_domain.h>
-#include <linux/pm_runtime.h>
 #include <linux/slab.h>
 
 #include "clk-scu.h"
@@ -20,20 +16,6 @@
 #define IMX_SIP_SET_CPUFREQ		0x00
 
 static struct imx_sc_ipc *ccm_ipc_handle;
-struct device_node *pd_np;
-
-struct imx_scu_clk_node {
-	const char *name;
-	u32 rsrc;
-	u8 clk_type;
-	const char * const *parents;
-	int num_parents;
-
-	struct clk_hw *hw;
-	struct list_head node;
-};
-
-struct list_head imx_scu_clks[IMX_SC_R_LAST];
 
 /*
  * struct clk_scu - Description of one SCU clock
@@ -45,10 +27,6 @@ struct clk_scu {
 	struct clk_hw hw;
 	u16 rsrc_id;
 	u8 clk_type;
-
-	/* for state save&restore */
-	bool is_enabled;
-	u32 rate;
 };
 
 /*
@@ -150,35 +128,9 @@ static inline struct clk_scu *to_clk_scu(struct clk_hw *hw)
 	return container_of(hw, struct clk_scu, hw);
 }
 
-int imx_clk_scu_init(struct device_node *np)
+int imx_clk_scu_init(void)
 {
-	struct platform_device *pd_dev;
-	u32 clk_cells;
-	int ret, i;
-
-	ret = imx_scu_get_handle(&ccm_ipc_handle);
-	if (ret)
-		return ret;
-
-	of_property_read_u32(np, "#clock-cells", &clk_cells);
-
-	if (clk_cells == 2) {
-		for (i = 0; i < IMX_SC_R_LAST; i++)
-			INIT_LIST_HEAD(&imx_scu_clks[i]);
-		/*
-		 * Note: SCU clock driver depends on SCU power domain to be ready
-		 * first. As there're no power domains under scu clock node in dts,
-		 * we can't use PROBE_DEFER automatically.
-		 */
-		pd_np = of_find_compatible_node(NULL, NULL, "fsl,scu-pd");
-		pd_dev = of_find_device_by_node(pd_np);
-		if (!pd_dev || !device_is_bound(&pd_dev->dev)) {
-			of_node_put(pd_np);
-			return -EPROBE_DEFER;
-		}
-	}
-
-	return 0;
+	return imx_scu_get_handle(&ccm_ipc_handle);
 }
 
 /*
@@ -392,9 +344,8 @@ static const struct clk_ops clk_scu_cpu_ops = {
 	.unprepare = clk_scu_unprepare,
 };
 
-struct clk_hw *__imx_clk_scu(struct device *dev, const char *name,
-			     const char * const *parents, int num_parents,
-			     u32 rsrc_id, u8 clk_type)
+struct clk_hw *__imx_clk_scu(const char *name, const char * const *parents,
+			     int num_parents, u32 rsrc_id, u8 clk_type)
 {
 	struct clk_init_data init;
 	struct clk_scu *clk;
@@ -428,186 +379,11 @@ struct clk_hw *__imx_clk_scu(struct device *dev, const char *name,
 	clk->hw.init = &init;
 
 	hw = &clk->hw;
-	ret = clk_hw_register(dev, hw);
+	ret = clk_hw_register(NULL, hw);
 	if (ret) {
 		kfree(clk);
 		hw = ERR_PTR(ret);
 	}
 
-	if (dev)
-		dev_set_drvdata(dev, clk);
-
 	return hw;
 }
-
-struct clk_hw *imx_scu_of_clk_src_get(struct of_phandle_args *clkspec,
-				      void *data)
-{
-	unsigned int rsrc = clkspec->args[0];
-	unsigned int idx = clkspec->args[1];
-	struct list_head *scu_clks = data;
-	struct imx_scu_clk_node *clk;
-
-	list_for_each_entry(clk, &scu_clks[rsrc], node) {
-		if (clk->clk_type == idx)
-			return clk->hw;
-	}
-
-	return ERR_PTR(-ENODEV);
-}
-
-static int imx_clk_scu_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct imx_scu_clk_node *clk = dev_get_platdata(dev);
-	struct clk_hw *hw;
-	int ret;
-
-	pm_runtime_set_suspended(dev);
-	pm_runtime_set_autosuspend_delay(dev, 50);
-	pm_runtime_use_autosuspend(&pdev->dev);
-	pm_runtime_enable(dev);
-
-	ret = pm_runtime_get_sync(dev);
-	if (ret) {
-		pm_runtime_disable(dev);
-		return ret;
-	}
-
-	hw = __imx_clk_scu(dev, clk->name, clk->parents, clk->num_parents,
-			   clk->rsrc, clk->clk_type);
-	if (IS_ERR(hw)) {
-		pm_runtime_disable(dev);
-		return PTR_ERR(hw);
-	}
-
-	clk->hw = hw;
-	list_add_tail(&clk->node, &imx_scu_clks[clk->rsrc]);
-
-	pm_runtime_mark_last_busy(&pdev->dev);
-	pm_runtime_put_autosuspend(&pdev->dev);
-
-	dev_dbg(dev, "register SCU clock rsrc:%d type:%d\n", clk->rsrc,
-		clk->clk_type);
-
-	return 0;
-}
-
-static int __maybe_unused imx_clk_scu_suspend(struct device *dev)
-{
-	struct clk_scu *clk = dev_get_drvdata(dev);
-
-	clk->rate = clk_hw_get_rate(&clk->hw);
-	clk->is_enabled = clk_hw_is_enabled(&clk->hw);
-
-	if (clk->rate)
-		dev_dbg(dev, "save rate %d\n", clk->rate);
-
-	if (clk->is_enabled)
-		dev_dbg(dev, "save enabled state\n");
-
-	return 0;
-}
-
-static int __maybe_unused imx_clk_scu_resume(struct device *dev)
-{
-	struct clk_scu *clk = dev_get_drvdata(dev);
-	int ret = 0;
-
-	if (clk->rate) {
-		ret = clk_scu_set_rate(&clk->hw, clk->rate, 0);
-		dev_dbg(dev, "restore rate %d %s\n", clk->rate,
-			!ret ? "success" : "failed");
-	}
-
-	if (clk->is_enabled) {
-		ret = clk_scu_prepare(&clk->hw);
-		dev_dbg(dev, "restore enabled state %s\n",
-			!ret ? "success" : "failed");
-	}
-
-	return ret;
-}
-
-static const struct dev_pm_ops imx_clk_scu_pm_ops = {
-	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(imx_clk_scu_suspend,
-				      imx_clk_scu_resume)
-};
-
-static struct platform_driver imx_clk_scu_driver = {
-	.driver = {
-		.name = "imx-scu-clk",
-		.suppress_bind_attrs = true,
-		.pm = &imx_clk_scu_pm_ops,
-	},
-	.probe = imx_clk_scu_probe,
-};
-builtin_platform_driver(imx_clk_scu_driver);
-
-static int imx_clk_scu_attach_pd(struct device *dev, u32 rsrc_id)
-{
-	struct of_phandle_args genpdspec = {
-		.np = pd_np,
-		.args_count = 1,
-		.args[0] = rsrc_id,
-	};
-
-	if (rsrc_id == IMX_SC_R_A35 || rsrc_id == IMX_SC_R_A53 ||
-	    rsrc_id == IMX_SC_R_A72)
-		return 0;
-
-	return of_genpd_add_device(&genpdspec, dev);
-}
-
-struct clk_hw *imx_clk_scu_alloc_dev(const char *name,
-				     const char * const *parents,
-				     int num_parents, u32 rsrc_id, u8 clk_type)
-{
-	struct imx_scu_clk_node clk = {
-		.name = name,
-		.rsrc = rsrc_id,
-		.clk_type = clk_type,
-		.parents = parents,
-		.num_parents = num_parents,
-	};
-	struct platform_device *pdev;
-	int ret;
-
-	pdev = platform_device_alloc(name, PLATFORM_DEVID_NONE);
-	if (!pdev) {
-		pr_err("%s: failed to allocate scu clk dev rsrc %d type %d\n",
-		       name, rsrc_id, clk_type);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	ret = platform_device_add_data(pdev, &clk, sizeof(clk));
-	if (ret) {
-		platform_device_put(pdev);
-		return ERR_PTR(ret);
-	}
-
-	pdev->driver_override = "imx-scu-clk";
-
-	ret = imx_clk_scu_attach_pd(&pdev->dev, rsrc_id);
-	if (ret)
-		pr_warn("%s: failed to attached the power domain %d\n",
-			name, ret);
-
-	platform_device_add(pdev);
-
-	/* For API backwards compatiblilty, simply return NULL for success */
-	return NULL;
-}
-
-void imx_clk_scu_unregister(void)
-{
-	struct imx_scu_clk_node *clk;
-	int i;
-
-	for (i = 0; i < IMX_SC_R_LAST; i++) {
-		list_for_each_entry(clk, &imx_scu_clks[i], node) {
-			clk_hw_unregister(clk->hw);
-			kfree(clk);
-		}
-	}
-}
diff --git a/drivers/clk/imx/clk-scu.h b/drivers/clk/imx/clk-scu.h
index e8352164923e..2bcfaf06a458 100644
--- a/drivers/clk/imx/clk-scu.h
+++ b/drivers/clk/imx/clk-scu.h
@@ -8,61 +8,25 @@
 #define __IMX_CLK_SCU_H
 
 #include <linux/firmware/imx/sci.h>
-#include <linux/of.h>
 
-extern struct list_head imx_scu_clks[];
-extern const struct dev_pm_ops imx_clk_lpcg_scu_pm_ops;
+int imx_clk_scu_init(void);
 
-int imx_clk_scu_init(struct device_node *np);
-struct clk_hw *imx_scu_of_clk_src_get(struct of_phandle_args *clkspec,
-				      void *data);
-struct clk_hw *imx_clk_scu_alloc_dev(const char *name,
-				     const char * const *parents,
-				     int num_parents, u32 rsrc_id, u8 clk_type);
-
-struct clk_hw *__imx_clk_scu(struct device *dev, const char *name,
-			     const char * const *parents, int num_parents,
-			     u32 rsrc_id, u8 clk_type);
-
-void imx_clk_scu_unregister(void);
-
-struct clk_hw *__imx_clk_lpcg_scu(struct device *dev, const char *name,
-				  const char *parent_name, unsigned long flags,
-				  void __iomem *reg, u8 bit_idx, bool hw_gate);
-void imx_clk_lpcg_scu_unregister(struct clk_hw *hw);
+struct clk_hw *__imx_clk_scu(const char *name, const char * const *parents,
+			     int num_parents, u32 rsrc_id, u8 clk_type);
 
 static inline struct clk_hw *imx_clk_scu(const char *name, u32 rsrc_id,
-					 u8 clk_type, u8 clk_cells)
+					 u8 clk_type)
 {
-	if (clk_cells == 2)
-		return imx_clk_scu_alloc_dev(name, NULL, 0, rsrc_id, clk_type);
-	else
-		return __imx_clk_scu(NULL, name, NULL, 0, rsrc_id, clk_type);
+	return __imx_clk_scu(name, NULL, 0, rsrc_id, clk_type);
 }
 
 static inline struct clk_hw *imx_clk_scu2(const char *name, const char * const *parents,
-					  int num_parents, u32 rsrc_id, u8 clk_type,
-					  u8 clk_cells)
-{
-	if (clk_cells == 2)
-		return imx_clk_scu_alloc_dev(name, parents, num_parents, rsrc_id, clk_type);
-	else
-		return __imx_clk_scu(NULL, name, parents, num_parents, rsrc_id, clk_type);
-}
-
-static inline struct clk_hw *imx_clk_lpcg_scu_dev(struct device *dev, const char *name,
-						  const char *parent_name, unsigned long flags,
-						  void __iomem *reg, u8 bit_idx, bool hw_gate)
+					  int num_parents, u32 rsrc_id, u8 clk_type)
 {
-	return __imx_clk_lpcg_scu(dev, name, parent_name, flags, reg,
-				  bit_idx, hw_gate);
+	return __imx_clk_scu(name, parents, num_parents, rsrc_id, clk_type);
 }
 
-static inline struct clk_hw *imx_clk_lpcg_scu(const char *name, const char *parent_name,
-					      unsigned long flags, void __iomem *reg,
-					      u8 bit_idx, bool hw_gate)
-{
-	return __imx_clk_lpcg_scu(NULL, name, parent_name, flags, reg,
-				  bit_idx, hw_gate);
-}
+struct clk_hw *imx_clk_lpcg_scu(const char *name, const char *parent_name,
+				unsigned long flags, void __iomem *reg,
+				u8 bit_idx, bool hw_gate);
 #endif
-- 
2.29.2

