From 49ac0f0a4560f34664d18356bf4e56d27529490d Mon Sep 17 00:00:00 2001
From: Nathan Chancellor <nathan@kernel.org>
Date: Wed, 3 Mar 2021 11:12:39 -0700
Subject: [PATCH 7/7] Revert "Merge remote-tracking branch 'keys/keys-next'"

This reverts commit 18d4bf031ac20ccd38a77b000be6426a6bdb6dc8, reversing
changes made to 5c1250eb34232beebbc4959dbc6e6f9c1cf8c479.

Link: https://lore.kernel.org/r/20210303181121.ii7ofii65lh337ln@archlinux-ax161/
Signed-off-by: Nathan Chancellor <nathan@kernel.org>
---
 certs/Kconfig                                 | 17 ------
 certs/Makefile                                | 20 +------
 certs/blacklist.c                             | 60 -------------------
 certs/blacklist.h                             |  2 -
 certs/common.c                                | 57 ------------------
 certs/common.h                                |  9 ---
 certs/revocation_certificates.S               | 21 -------
 certs/system_keyring.c                        | 55 ++++++++++++++---
 include/keys/system_keyring.h                 | 15 -----
 scripts/Makefile                              |  1 -
 .../platform_certs/keyring_handler.c          | 11 ----
 security/integrity/platform_certs/load_uefi.c | 20 +------
 12 files changed, 51 insertions(+), 237 deletions(-)
 delete mode 100644 certs/common.c
 delete mode 100644 certs/common.h
 delete mode 100644 certs/revocation_certificates.S

diff --git a/certs/Kconfig b/certs/Kconfig
index ab88d2a7f3c7..c94e93d8bccf 100644
--- a/certs/Kconfig
+++ b/certs/Kconfig
@@ -83,21 +83,4 @@ config SYSTEM_BLACKLIST_HASH_LIST
 	  wrapper to incorporate the list into the kernel.  Each <hash> should
 	  be a string of hex digits.
 
-config SYSTEM_REVOCATION_LIST
-	bool "Provide system-wide ring of revocation certificates"
-	depends on SYSTEM_BLACKLIST_KEYRING
-	depends on PKCS7_MESSAGE_PARSER=y
-	help
-	  If set, this allows revocation certificates to be stored in the
-	  blacklist keyring and implements a hook whereby a PKCS#7 message can
-	  be checked to see if it matches such a certificate.
-
-config SYSTEM_REVOCATION_KEYS
-	string "X.509 certificates to be preloaded into the system blacklist keyring"
-	depends on SYSTEM_REVOCATION_LIST
-	help
-	  If set, this option should be the filename of a PEM-formatted file
-	  containing X.509 certificates to be included in the default blacklist
-	  keyring.
-
 endmenu
diff --git a/certs/Makefile b/certs/Makefile
index e3f4926fd21e..f4c25b67aad9 100644
--- a/certs/Makefile
+++ b/certs/Makefile
@@ -3,8 +3,8 @@
 # Makefile for the linux kernel signature checking certificates.
 #
 
-obj-$(CONFIG_SYSTEM_TRUSTED_KEYRING) += system_keyring.o system_certificates.o common.o
-obj-$(CONFIG_SYSTEM_BLACKLIST_KEYRING) += blacklist.o revocation_certificates.o common.o
+obj-$(CONFIG_SYSTEM_TRUSTED_KEYRING) += system_keyring.o system_certificates.o
+obj-$(CONFIG_SYSTEM_BLACKLIST_KEYRING) += blacklist.o
 ifneq ($(CONFIG_SYSTEM_BLACKLIST_HASH_LIST),"")
 obj-$(CONFIG_SYSTEM_BLACKLIST_KEYRING) += blacklist_hashes.o
 else
@@ -29,7 +29,7 @@ $(obj)/x509_certificate_list: scripts/extract-cert $(SYSTEM_TRUSTED_KEYS_SRCPREF
 	$(call if_changed,extract_certs,$(SYSTEM_TRUSTED_KEYS_SRCPREFIX)$(CONFIG_SYSTEM_TRUSTED_KEYS))
 endif # CONFIG_SYSTEM_TRUSTED_KEYRING
 
-clean-files := x509_certificate_list .x509.list x509_revocation_list
+clean-files := x509_certificate_list .x509.list
 
 ifeq ($(CONFIG_MODULE_SIG),y)
 ###############################################################################
@@ -104,17 +104,3 @@ targets += signing_key.x509
 $(obj)/signing_key.x509: scripts/extract-cert $(X509_DEP) FORCE
 	$(call if_changed,extract_certs,$(MODULE_SIG_KEY_SRCPREFIX)$(CONFIG_MODULE_SIG_KEY))
 endif # CONFIG_MODULE_SIG
-
-ifeq ($(CONFIG_SYSTEM_BLACKLIST_KEYRING),y)
-
-$(eval $(call config_filename,SYSTEM_REVOCATION_KEYS))
-
-$(obj)/revocation_certificates.o: $(obj)/x509_revocation_list
-
-quiet_cmd_extract_certs  = EXTRACT_CERTS   $(patsubst "%",%,$(2))
-      cmd_extract_certs  = scripts/extract-cert $(2) $@
-
-targets += x509_revocation_list
-$(obj)/x509_revocation_list: scripts/extract-cert $(SYSTEM_REVOCATION_KEYS_SRCPREFIX)$(SYSTEM_REVOCATION_KEYS_FILENAME) FORCE
-	$(call if_changed,extract_certs,$(SYSTEM_REVOCATION_KEYS_SRCPREFIX)$(CONFIG_SYSTEM_REVOCATION_KEYS))
-endif
diff --git a/certs/blacklist.c b/certs/blacklist.c
index 723b19c96256..bffe4c6f4a9e 100644
--- a/certs/blacklist.c
+++ b/certs/blacklist.c
@@ -17,13 +17,9 @@
 #include <linux/uidgid.h>
 #include <keys/system_keyring.h>
 #include "blacklist.h"
-#include "common.h"
 
 static struct key *blacklist_keyring;
 
-extern __initconst const u8 revocation_certificate_list[];
-extern __initconst const unsigned long revocation_certificate_list_size;
-
 /*
  * The description must be a type prefix, a colon and then an even number of
  * hex digits.  The hash is kept in the description.
@@ -149,49 +145,6 @@ int is_binary_blacklisted(const u8 *hash, size_t hash_len)
 }
 EXPORT_SYMBOL_GPL(is_binary_blacklisted);
 
-#ifdef CONFIG_SYSTEM_REVOCATION_LIST
-/**
- * add_key_to_revocation_list - Add a revocation certificate to the blacklist
- * @data: The data blob containing the certificate
- * @size: The size of data blob
- */
-int add_key_to_revocation_list(const char *data, size_t size)
-{
-	key_ref_t key;
-
-	key = key_create_or_update(make_key_ref(blacklist_keyring, true),
-				   "asymmetric",
-				   NULL,
-				   data,
-				   size,
-				   ((KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW),
-				   KEY_ALLOC_NOT_IN_QUOTA | KEY_ALLOC_BUILT_IN);
-
-	if (IS_ERR(key)) {
-		pr_err("Problem with revocation key (%ld)\n", PTR_ERR(key));
-		return PTR_ERR(key);
-	}
-
-	return 0;
-}
-
-/**
- * is_key_on_revocation_list - Determine if the key for a PKCS#7 message is revoked
- * @pkcs7: The PKCS#7 message to check
- */
-int is_key_on_revocation_list(struct pkcs7_message *pkcs7)
-{
-	int ret;
-
-	ret = pkcs7_validate_trust(pkcs7, blacklist_keyring);
-
-	if (ret == 0)
-		return -EKEYREJECTED;
-
-	return -ENOKEY;
-}
-#endif
-
 /*
  * Initialise the blacklist
  */
@@ -224,16 +177,3 @@ static int __init blacklist_init(void)
  * Must be initialised before we try and load the keys into the keyring.
  */
 device_initcall(blacklist_init);
-
-/*
- * Load the compiled-in list of revocation X.509 certificates.
- */
-static __init int load_revocation_certificate_list(void)
-{
-	if (revocation_certificate_list_size)
-		pr_notice("Loading compiled-in revocation X.509 certificates\n");
-
-	return load_certificate_list(revocation_certificate_list, revocation_certificate_list_size,
-				     blacklist_keyring);
-}
-late_initcall(load_revocation_certificate_list);
diff --git a/certs/blacklist.h b/certs/blacklist.h
index 51b320cf8574..1efd6fa0dc60 100644
--- a/certs/blacklist.h
+++ b/certs/blacklist.h
@@ -1,5 +1,3 @@
 #include <linux/kernel.h>
-#include <linux/errno.h>
-#include <crypto/pkcs7.h>
 
 extern const char __initconst *const blacklist_hashes[];
diff --git a/certs/common.c b/certs/common.c
deleted file mode 100644
index 16a220887a53..000000000000
--- a/certs/common.c
+++ /dev/null
@@ -1,57 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-
-#include <linux/kernel.h>
-#include <linux/key.h>
-#include "common.h"
-
-int load_certificate_list(const u8 cert_list[],
-			  const unsigned long list_size,
-			  const struct key *keyring)
-{
-	key_ref_t key;
-	const u8 *p, *end;
-	size_t plen;
-
-	p = cert_list;
-	end = p + list_size;
-	while (p < end) {
-		/* Each cert begins with an ASN.1 SEQUENCE tag and must be more
-		 * than 256 bytes in size.
-		 */
-		if (end - p < 4)
-			goto dodgy_cert;
-		if (p[0] != 0x30 &&
-		    p[1] != 0x82)
-			goto dodgy_cert;
-		plen = (p[2] << 8) | p[3];
-		plen += 4;
-		if (plen > end - p)
-			goto dodgy_cert;
-
-		key = key_create_or_update(make_key_ref(keyring, 1),
-					   "asymmetric",
-					   NULL,
-					   p,
-					   plen,
-					   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |
-					   KEY_USR_VIEW | KEY_USR_READ),
-					   KEY_ALLOC_NOT_IN_QUOTA |
-					   KEY_ALLOC_BUILT_IN |
-					   KEY_ALLOC_BYPASS_RESTRICTION);
-		if (IS_ERR(key)) {
-			pr_err("Problem loading in-kernel X.509 certificate (%ld)\n",
-			       PTR_ERR(key));
-		} else {
-			pr_notice("Loaded X.509 cert '%s'\n",
-				  key_ref_to_ptr(key)->description);
-			key_ref_put(key);
-		}
-		p += plen;
-	}
-
-	return 0;
-
-dodgy_cert:
-	pr_err("Problem parsing in-kernel X.509 certificate list\n");
-	return 0;
-}
diff --git a/certs/common.h b/certs/common.h
deleted file mode 100644
index abdb5795936b..000000000000
--- a/certs/common.h
+++ /dev/null
@@ -1,9 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-
-#ifndef _CERT_COMMON_H
-#define _CERT_COMMON_H
-
-int load_certificate_list(const u8 cert_list[], const unsigned long list_size,
-			  const struct key *keyring);
-
-#endif
diff --git a/certs/revocation_certificates.S b/certs/revocation_certificates.S
deleted file mode 100644
index f21aae8a8f0e..000000000000
--- a/certs/revocation_certificates.S
+++ /dev/null
@@ -1,21 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/export.h>
-#include <linux/init.h>
-
-	__INITRODATA
-
-	.align 8
-	.globl revocation_certificate_list
-revocation_certificate_list:
-__revocation_list_start:
-	.incbin "certs/x509_revocation_list"
-__revocation_list_end:
-
-	.align 8
-	.globl revocation_certificate_list_size
-revocation_certificate_list_size:
-#ifdef CONFIG_64BIT
-	.quad __revocation_list_end - __revocation_list_start
-#else
-	.long __revocation_list_end - __revocation_list_start
-#endif
diff --git a/certs/system_keyring.c b/certs/system_keyring.c
index 0c9a4795e847..4b693da488f1 100644
--- a/certs/system_keyring.c
+++ b/certs/system_keyring.c
@@ -16,7 +16,6 @@
 #include <keys/asymmetric-type.h>
 #include <keys/system_keyring.h>
 #include <crypto/pkcs7.h>
-#include "common.h"
 
 static struct key *builtin_trusted_keys;
 #ifdef CONFIG_SECONDARY_TRUSTED_KEYRING
@@ -138,10 +137,54 @@ device_initcall(system_trusted_keyring_init);
  */
 static __init int load_system_certificate_list(void)
 {
+	key_ref_t key;
+	const u8 *p, *end;
+	size_t plen;
+
 	pr_notice("Loading compiled-in X.509 certificates\n");
 
-	return load_certificate_list(system_certificate_list, system_certificate_list_size,
-				     builtin_trusted_keys);
+	p = system_certificate_list;
+	end = p + system_certificate_list_size;
+	while (p < end) {
+		/* Each cert begins with an ASN.1 SEQUENCE tag and must be more
+		 * than 256 bytes in size.
+		 */
+		if (end - p < 4)
+			goto dodgy_cert;
+		if (p[0] != 0x30 &&
+		    p[1] != 0x82)
+			goto dodgy_cert;
+		plen = (p[2] << 8) | p[3];
+		plen += 4;
+		if (plen > end - p)
+			goto dodgy_cert;
+
+		key = key_create_or_update(make_key_ref(builtin_trusted_keys, 1),
+					   "asymmetric",
+					   NULL,
+					   p,
+					   plen,
+					   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |
+					   KEY_USR_VIEW | KEY_USR_READ),
+					   KEY_ALLOC_NOT_IN_QUOTA |
+					   KEY_ALLOC_BUILT_IN |
+					   KEY_ALLOC_BYPASS_RESTRICTION);
+		if (IS_ERR(key)) {
+			pr_err("Problem loading in-kernel X.509 certificate (%ld)\n",
+			       PTR_ERR(key));
+		} else {
+			pr_notice("Loaded X.509 cert '%s'\n",
+				  key_ref_to_ptr(key)->description);
+			key_ref_put(key);
+		}
+		p += plen;
+	}
+
+	return 0;
+
+dodgy_cert:
+	pr_err("Problem parsing in-kernel X.509 certificate list\n");
+	return 0;
 }
 late_initcall(load_system_certificate_list);
 
@@ -199,12 +242,6 @@ int verify_pkcs7_message_sig(const void *data, size_t len,
 			pr_devel("PKCS#7 platform keyring is not available\n");
 			goto error;
 		}
-
-		ret = is_key_on_revocation_list(pkcs7);
-		if (ret != -ENOKEY) {
-			pr_devel("PKCS#7 platform key is on revocation list\n");
-			goto error;
-		}
 	}
 	ret = pkcs7_validate_trust(pkcs7, trusted_keys);
 	if (ret < 0) {
diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index 875e002a4180..fb8b07daa9d1 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -31,7 +31,6 @@ extern int restrict_link_by_builtin_and_secondary_trusted(
 #define restrict_link_by_builtin_and_secondary_trusted restrict_link_by_builtin_trusted
 #endif
 
-extern struct pkcs7_message *pkcs7;
 #ifdef CONFIG_SYSTEM_BLACKLIST_KEYRING
 extern int mark_hash_blacklisted(const char *hash);
 extern int is_hash_blacklisted(const u8 *hash, size_t hash_len,
@@ -50,20 +49,6 @@ static inline int is_binary_blacklisted(const u8 *hash, size_t hash_len)
 }
 #endif
 
-#ifdef CONFIG_SYSTEM_REVOCATION_LIST
-extern int add_key_to_revocation_list(const char *data, size_t size);
-extern int is_key_on_revocation_list(struct pkcs7_message *pkcs7);
-#else
-static inline int add_key_to_revocation_list(const char *data, size_t size)
-{
-	return 0;
-}
-static inline int is_key_on_revocation_list(struct pkcs7_message *pkcs7)
-{
-	return -ENOKEY;
-}
-#endif
-
 #ifdef CONFIG_IMA_BLACKLIST_KEYRING
 extern struct key *ima_blacklist_keyring;
 
diff --git a/scripts/Makefile b/scripts/Makefile
index b49bf932ccdc..c36106bce80e 100644
--- a/scripts/Makefile
+++ b/scripts/Makefile
@@ -14,7 +14,6 @@ hostprogs-always-$(CONFIG_ASN1)				+= asn1_compiler
 hostprogs-always-$(CONFIG_MODULE_SIG_FORMAT)		+= sign-file
 hostprogs-always-$(CONFIG_SYSTEM_TRUSTED_KEYRING)	+= extract-cert
 hostprogs-always-$(CONFIG_SYSTEM_EXTRA_CERTIFICATE)	+= insert-sys-cert
- hostprogs-always-$(CONFIG_SYSTEM_BLACKLIST_KEYRING)	+= extract-cert
 
 HOSTCFLAGS_sorttable.o = -I$(srctree)/tools/include
 HOSTCFLAGS_asn1_compiler.o = -I$(srctree)/include
diff --git a/security/integrity/platform_certs/keyring_handler.c b/security/integrity/platform_certs/keyring_handler.c
index 5604bd57c990..c5ba695c10e3 100644
--- a/security/integrity/platform_certs/keyring_handler.c
+++ b/security/integrity/platform_certs/keyring_handler.c
@@ -55,15 +55,6 @@ static __init void uefi_blacklist_binary(const char *source,
 	uefi_blacklist_hash(source, data, len, "bin:", 4);
 }
 
-/*
- * Add an X509 cert to the revocation list.
- */
-static __init void uefi_revocation_list_x509(const char *source,
-					     const void *data, size_t len)
-{
-	add_key_to_revocation_list(data, len);
-}
-
 /*
  * Return the appropriate handler for particular signature list types found in
  * the UEFI db and MokListRT tables.
@@ -85,7 +76,5 @@ __init efi_element_handler_t get_handler_for_dbx(const efi_guid_t *sig_type)
 		return uefi_blacklist_x509_tbs;
 	if (efi_guidcmp(*sig_type, efi_cert_sha256_guid) == 0)
 		return uefi_blacklist_binary;
-	if (efi_guidcmp(*sig_type, efi_cert_x509_guid) == 0)
-		return uefi_revocation_list_x509;
 	return 0;
 }
diff --git a/security/integrity/platform_certs/load_uefi.c b/security/integrity/platform_certs/load_uefi.c
index f290f78c3f30..ee4b4c666854 100644
--- a/security/integrity/platform_certs/load_uefi.c
+++ b/security/integrity/platform_certs/load_uefi.c
@@ -132,9 +132,8 @@ static int __init load_moklist_certs(void)
 static int __init load_uefi_certs(void)
 {
 	efi_guid_t secure_var = EFI_IMAGE_SECURITY_DATABASE_GUID;
-	efi_guid_t mok_var = EFI_SHIM_LOCK_GUID;
-	void *db = NULL, *dbx = NULL, *mokx = NULL;
-	unsigned long dbsize = 0, dbxsize = 0, mokxsize = 0;
+	void *db = NULL, *dbx = NULL;
+	unsigned long dbsize = 0, dbxsize = 0;
 	efi_status_t status;
 	int rc = 0;
 
@@ -176,21 +175,6 @@ static int __init load_uefi_certs(void)
 		kfree(dbx);
 	}
 
-	mokx = get_cert_list(L"MokListXRT", &mok_var, &mokxsize, &status);
-	if (!mokx) {
-		if (status == EFI_NOT_FOUND)
-			pr_debug("mokx variable wasn't found\n");
-		else
-			pr_info("Couldn't get mokx list\n");
-	} else {
-		rc = parse_efi_signature_list("UEFI:MokListXRT",
-					      mokx, mokxsize,
-					      get_handler_for_dbx);
-		if (rc)
-			pr_err("Couldn't parse mokx signatures %d\n", rc);
-		kfree(mokx);
-	}
-
 	/* Load the MokListRT certs */
 	rc = load_moklist_certs();
 
-- 
2.31.0.rc0.75.gec125d1bc1

