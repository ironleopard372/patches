From ee3bb21bb42558a04277a5c3c7c6188c2e72b976 Mon Sep 17 00:00:00 2001
From: Nathan Chancellor <nathan@kernel.org>
Date: Wed, 10 Mar 2021 13:06:45 -0700
Subject: [PATCH 13/14] x86/vmemmap: Apply v6 diff to resolve build error

Link: https://lore.kernel.org/r/CA+G9fYuP9t7Giyjmh4-2UspD1hfEF5EQwZ69xKWAaBH99ykxtA@mail.gmail.com/
Signed-off-by: Nathan Chancellor <nathan@kernel.org>
---
 arch/x86/mm/init_64.c | 147 ++++++++++++++----------------------------
 1 file changed, 49 insertions(+), 98 deletions(-)

diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c
index 6e6f8927283b..0b5d6459391e 100644
--- a/arch/x86/mm/init_64.c
+++ b/arch/x86/mm/init_64.c
@@ -828,6 +828,51 @@ void __init paging_init(void)
 	zone_sizes_init();
 }
 
+#ifdef CONFIG_SPARSEMEM_VMEMMAP
+#define PAGE_UNUSED 0xFD
+
+/* Returns true if the PMD is completely unused and thus it can be freed */
+static bool __meminit vmemmap_pmd_is_unused(unsigned long addr, unsigned long end)
+{
+	unsigned long start = ALIGN_DOWN(addr, PMD_SIZE);
+
+	memset((void *)addr, PAGE_UNUSED, end - addr);
+
+	return !memchr_inv((void *)start, PAGE_UNUSED, PMD_SIZE);
+}
+
+static void __meminit vmemmap_use_sub_pmd(unsigned long start)
+{
+	/*
+	 * As we expect to add in the same granularity as we remove, it's
+	 * sufficient to mark only some piece used to block the memmap page from
+	 * getting removed when removing some other adjacent memmap (just in
+	 * case the first memmap never gets initialized e.g., because the memory
+	 * block never gets onlined).
+	 */
+	memset((void *)start, 0, sizeof(struct page));
+}
+
+static void __meminit vmemmap_use_new_sub_pmd(unsigned long start, unsigned long end)
+{
+	/*
+	 * Could be our memmap page is filled with PAGE_UNUSED already from a
+	 * previous remove. Make sure to reset it.
+	 */
+	vmemmap_use_sub_pmd(start);
+
+	/*
+	 * Mark with PAGE_UNUSED the unused parts of the new memmap range
+	 */
+	if (!IS_ALIGNED(start, PMD_SIZE))
+		memset((void *)start, PAGE_UNUSED,
+		        start - ALIGN_DOWN(start, PMD_SIZE));
+	if (!IS_ALIGNED(end, PMD_SIZE))
+		memset((void *)end, PAGE_UNUSED,
+		        ALIGN(end, PMD_SIZE) - end);
+}
+#endif
+
 /*
  * Memory hotplug specific functions
  */
@@ -873,94 +918,6 @@ int arch_add_memory(int nid, u64 start, u64 size,
 	return add_pages(nid, start_pfn, nr_pages, params);
 }
 
-#ifdef CONFIG_SPARSEMEM_VMEMMAP
-#define PAGE_UNUSED 0xFD
-
-/*
- * The unused vmemmap range, which was not yet memset(PAGE_UNUSED) ranges
- * from unused_pmd_start to next PMD_SIZE boundary.
- */
-static unsigned long unused_pmd_start __meminitdata;
-
-static void __meminit vmemmap_flush_unused_pmd(void)
-{
-	if (!unused_pmd_start)
-		return;
-	/*
-	 * Clears (unused_pmd_start, PMD_END]
-	 */
-	memset((void *)unused_pmd_start, PAGE_UNUSED,
-	       ALIGN(unused_pmd_start, PMD_SIZE) - unused_pmd_start);
-	unused_pmd_start = 0;
-}
-
-/* Returns true if the PMD is completely unused and thus it can be freed */
-static bool __meminit vmemmap_unuse_sub_pmd(unsigned long addr, unsigned long end)
-{
-	unsigned long start = ALIGN_DOWN(addr, PMD_SIZE);
-
-	vmemmap_flush_unused_pmd();
-	memset((void *)addr, PAGE_UNUSED, end - addr);
-
-	return !memchr_inv((void *)start, PAGE_UNUSED, PMD_SIZE);
-}
-
-static void __meminit __vmemmap_use_sub_pmd(unsigned long start)
-{
-	/*
-	 * As we expect to add in the same granularity as we remove, it's
-	 * sufficient to mark only some piece used to block the memmap page from
-	 * getting removed when removing some other adjacent memmap (just in
-	 * case the first memmap never gets initialized e.g., because the memory
-	 * block never gets onlined).
-	 */
-	memset((void *)start, 0, sizeof(struct page));
-}
-
-static void __meminit vmemmap_use_sub_pmd(unsigned long start, unsigned long end)
-{
-	/*
-	 * We only optimize if the new used range directly follows the
-	 * previously unused range (esp., when populating consecutive sections).
-	 */
-	if (unused_pmd_start == start) {
-		if (likely(IS_ALIGNED(end, PMD_SIZE)))
-			unused_pmd_start = 0;
-		else
-			unused_pmd_start = end;
-		return;
-	}
-
-	vmemmap_flush_unused_pmd();
-	__vmemmap_use_sub_pmd(start);
-}
-
-static void __meminit vmemmap_use_new_sub_pmd(unsigned long start, unsigned long end)
-{
-	vmemmap_flush_unused_pmd();
-
-	/*
-	 * Could be our memmap page is filled with PAGE_UNUSED already from a
-	 * previous remove.
-	 */
-	__vmemmap_use_sub_pmd(start);
-
-	/*
-	 * Mark the unused parts of the new memmap range
-	 */
-	if (!IS_ALIGNED(start, PMD_SIZE))
-		memset((void *)start, PAGE_UNUSED,
-		       start - ALIGN_DOWN(start, PMD_SIZE));
-	/*
-	 * We want to avoid memset(PAGE_UNUSED) when populating the vmemmap of
-	 * consecutive sections. Remember for the last added PMD the last
-	 * unused range in the populated PMD.
-	 */
-	if (!IS_ALIGNED(end, PMD_SIZE))
-		unused_pmd_start = end;
-}
-#endif
-
 static void __meminit free_pagetable(struct page *page, int order)
 {
 	unsigned long magic;
@@ -1113,20 +1070,13 @@ remove_pmd_table(pmd_t *pmd_start, unsigned long addr, unsigned long end,
 				pmd_clear(pmd);
 				spin_unlock(&init_mm.page_table_lock);
 				pages++;
-			} else {
-#ifdef CONFIG_SPARSEMEM_VMEMMAP
-				/*
-				 * Free the PMD if the whole range is unused.
-				 */
-				if (vmemmap_unuse_sub_pmd(addr, next)) {
+			} else if (IS_ENABLED(CONFIG_SPARSEMEM_VMEMMAP) &&
+				   vmemmap_pmd_is_unused(addr, next)) {
 					free_hugepage_table(pmd_page(*pmd),
 							    altmap);
-
 					spin_lock(&init_mm.page_table_lock);
 					pmd_clear(pmd);
 					spin_unlock(&init_mm.page_table_lock);
-				}
-#endif
 			}
 
 			continue;
@@ -1583,12 +1533,13 @@ static int __meminit vmemmap_populate_hugepages(unsigned long start,
 				if (!IS_ALIGNED(addr, PMD_SIZE) ||
 				    !IS_ALIGNED(next, PMD_SIZE))
 					vmemmap_use_new_sub_pmd(addr, next);
+
 				continue;
 			} else if (altmap)
 				return -ENOMEM; /* no fallback */
 		} else if (pmd_large(*pmd)) {
 			vmemmap_verify((pte_t *)pmd, node, addr, next);
-			vmemmap_use_sub_pmd(addr, next);
+			vmemmap_use_sub_pmd(addr);
 			continue;
 		}
 		if (vmemmap_populate_basepages(addr, next, node, NULL))
-- 
2.31.0.rc1

