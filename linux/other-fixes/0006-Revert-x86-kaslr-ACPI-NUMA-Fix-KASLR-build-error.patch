From 6330bf99d13466dc0802202f50e2893fc917d420 Mon Sep 17 00:00:00 2001
From: Nathan Chancellor <natechancellor@gmail.com>
Date: Tue, 9 Oct 2018 10:24:32 -0700
Subject: [PATCH 6/7] Revert "x86/kaslr, ACPI/NUMA: Fix KASLR build error"

This version is broken.

This reverts commit 3a387c6d96e69f1710a3804eb68e1253263298f2.

Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
---
 arch/x86/include/asm/kaslr.h |  2 --
 arch/x86/include/asm/setup.h |  2 ++
 arch/x86/mm/kaslr.c          | 19 +------------------
 drivers/acpi/numa.c          | 15 ++++++++++++---
 4 files changed, 15 insertions(+), 23 deletions(-)

diff --git a/arch/x86/include/asm/kaslr.h b/arch/x86/include/asm/kaslr.h
index 95ef3fc01d12..db7ba2feb947 100644
--- a/arch/x86/include/asm/kaslr.h
+++ b/arch/x86/include/asm/kaslr.h
@@ -6,10 +6,8 @@ unsigned long kaslr_get_random_long(const char *purpose);
 
 #ifdef CONFIG_RANDOMIZE_MEMORY
 void kernel_randomize_memory(void);
-void kaslr_check_padding(void);
 #else
 static inline void kernel_randomize_memory(void) { }
-static inline void kaslr_check_padding(void) { }
 #endif /* CONFIG_RANDOMIZE_MEMORY */
 
 #endif
diff --git a/arch/x86/include/asm/setup.h b/arch/x86/include/asm/setup.h
index ae13bc974416..65a5bf8f6aba 100644
--- a/arch/x86/include/asm/setup.h
+++ b/arch/x86/include/asm/setup.h
@@ -80,6 +80,8 @@ static inline unsigned long kaslr_offset(void)
 	return (unsigned long)&_text - __START_KERNEL;
 }
 
+extern int rand_mem_physical_padding;
+
 /*
  * Do NOT EVER look at the BIOS memory size location.
  * It does not work on many machines.
diff --git a/arch/x86/mm/kaslr.c b/arch/x86/mm/kaslr.c
index ad80bdc690c1..00cf4cae38f5 100644
--- a/arch/x86/mm/kaslr.c
+++ b/arch/x86/mm/kaslr.c
@@ -23,7 +23,6 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/random.h>
-#include <linux/memblock.h>
 
 #include <asm/pgalloc.h>
 #include <asm/pgtable.h>
@@ -41,7 +40,7 @@
  */
 static const unsigned long vaddr_end = CPU_ENTRY_AREA_BASE;
 
-static int __initdata rand_mem_physical_padding = CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING;
+int __initdata rand_mem_physical_padding = CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING;
 /*
  * Memory regions randomized by KASLR (except modules that use a separate logic
  * earlier during boot). The list is ordered based on virtual addresses. This
@@ -71,22 +70,6 @@ static inline bool kaslr_memory_enabled(void)
 	return kaslr_enabled() && !IS_ENABLED(CONFIG_KASAN);
 }
 
-/*
- * Check the padding size for KASLR is enough.
- */
-void __init kaslr_check_padding(void)
-{
-	u64 max_possible_phys, max_actual_phys, threshold;
-
-	max_actual_phys = roundup(PFN_PHYS(max_pfn), 1ULL << 40);
-	max_possible_phys = roundup(PFN_PHYS(max_possible_pfn), 1ULL << 40);
-	threshold = max_actual_phys + ((u64)rand_mem_physical_padding << 40);
-
-	if (max_possible_phys > threshold)
-		pr_warn("Set 'rand_mem_physical_padding=%llu' to avoid memory hotadd failure.\n",
-			(max_possible_phys - max_actual_phys) >> 40);
-}
-
 static int __init rand_mem_physical_padding_setup(char *str)
 {
 	int max_padding = (1 << (MAX_PHYSMEM_BITS - TB_SHIFT)) - 1;
diff --git a/drivers/acpi/numa.c b/drivers/acpi/numa.c
index 9038800f45d2..9bc038676233 100644
--- a/drivers/acpi/numa.c
+++ b/drivers/acpi/numa.c
@@ -31,7 +31,7 @@
 #include <linux/numa.h>
 #include <linux/nodemask.h>
 #include <linux/topology.h>
-#include <asm/kaslr.h>
+#include <asm/setup.h>
 
 static nodemask_t nodes_found_map = NODE_MASK_NONE;
 
@@ -435,6 +435,7 @@ acpi_table_parse_srat(enum acpi_srat_type id,
 int __init acpi_numa_init(void)
 {
 	int cnt = 0;
+	u64 max_possible_phys, max_actual_phys, threshold;
 
 	if (acpi_disabled)
 		return -EINVAL;
@@ -464,9 +465,17 @@ int __init acpi_numa_init(void)
 		cnt = acpi_table_parse_srat(ACPI_SRAT_TYPE_MEMORY_AFFINITY,
 					    acpi_parse_memory_affinity, 0);
 
-		if (parsed_numa_memblks)
-			kaslr_check_padding();
+		/* check the padding size for KASLR is enough. */
+		if (parsed_numa_memblks && kaslr_enabled()) {
+			max_actual_phys = roundup(PFN_PHYS(max_pfn), 1ULL << 40);
+			max_possible_phys = roundup(PFN_PHYS(max_possible_pfn), 1ULL << 40);
+			threshold = max_actual_phys + ((u64)rand_mem_physical_padding << 40);
 
+			if (max_possible_phys > threshold) {
+				pr_warn("Set 'rand_mem_physical_padding=%llu' to avoid memory hotadd failure.\n",
+				  (max_possible_phys - max_actual_phys) >> 40);
+			}
+		}
 	}
 
 	/* SLIT: System Locality Information Table */
-- 
2.19.0

